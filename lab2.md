# lab2: CAN Bus and Multitasking

## Objectives
Objectives
- Learn the mbed CAN API and the basic underlying principles/
- Learn about and use the different multitasking models on a CAN node.

## Introduction
[CAN (Controller Area Network)](https://en.wikipedia.org/wiki/CAN_bus) is a communications standard used to network electronics in vehicles, including our solar car. While commercial vehicles also have other network standards to choose from (and some may use a combination of several), all the networked devices (including battery management system, motor controller, telemetry, MPPT) on our car communicate over a shared CAN bus.

### Interface Level
A CAN bus consists of at least two devices (nodes) connected to a shared bus, and is a _message-based_, _broadcast_ network:
- Message-based: transmissions occur in complete messages (also called frames).
- Broadcast: all nodes on the network can hear the transmissions of any node (though they need not act on irrelevant messages).

The two main operations are transmitting and receiving messages.

### Message Format
CAN messages carry these pieces of user data:
- ID field, either 11 bits (standard frame) or 29 bits (extended frame). A lower ID gives the message priority in the event of a collision (which happens when multiple nodes start transmitting simultaneously).
- Data, up to 8 bytes. The length is transmitted as part of the frame.
- Remote transmission request (RTR), one bit. This differentiates a remote request frame from a data frame, and more details are below.

The ID field is used to indicate the kind of data being transmitted (for example, "battery voltage") and the data field contains the actual data (continuing the example, 107.4 V encoded as 2 bytes fixed point). Message IDs must be unique on any single CAN bus. Because of the priority system, giving a lower ID to more important messages (or messages with stricter deadlines) is recommended.

Usually, nodes transmit data regularly (for example, battery voltage is automatically sent every second by the BMS), but the RTR field can be used to request specific data. Responding to RTR messages must be handled by application code, and it's not something we use.

CAN also provides these non-user data fields:
- [Cyclic Redundancy Check (CRC)](https://en.wikipedia.org/wiki/Cyclic_redundancy_check), 15 bits, as a checksum so corrupted messages are discarded.
- Acknowledgement, one bit, asserted by any other node upon successful reception (including CRC check).
  - If a message is not acknowledged by any other node, the transmitter will attempt to retransmit.
  - However, it is impossible to tell from the acknowledgement bit if a message was received by a particular node.
  - As acknowledgements are generated by the CAN controller peripheral (before user-level code), it is also impossible to tell if application code has processed and acted on a message correctly.

### Errors
CAN controllers keep count of errors, and too many errors may result in a _bus-off_ condition, where the controller disconnects from the bus. The CAN controller must be re-initialized (through user-level code) before communications can resume. The full list of error counter rules is complex and a more detailed explanation is [here](https://www.kvaser.com/about-can/the-can-protocol/can-error-handling/).

### Physical Layer
_This is only a very high-level overview._

The CAN bus itself consists of two wires, CANH and CANL as a differential pair, to which all nodes are attached. There are two bit levels, either dominant (0) or recessive (1). When multiple nodes transmit simultaneously (collision), a dominant bit takes priority over a recessive bit (the mechanism for ID-based arbitration). If no node is transmitting, the bus is held at a recessive level.

The CAN controller operates on two different, single-ended (non-differential), logic-level lines: TXD and RXD. RXD indicates the current bit level on the CANH/CANL lines, while TXD indicates the bit to transmit.

A CAN transceiver bridges the logic-level TXD/RXD lines and the bus-level CANH/CANL lines. While CAN controllers may be a on-chip peripheral on some microcontrollers, CAN transceivers are usually separate chips and may provide some degree of electrical isolation.

## Lab 2.1: Getting Started: Hardware
The LPC1549 on the BRAINv3.3 has a CAN controller, but no onboard CAN transceiver. You will need to connect the BRAIN to an external CAN transceiver breakout: connect one BRAIN IO to RXD, another to TXD, and the power supply (Vcc and GND) to the 3.3v microcontroller supply. Connect the CAN side lines (CANH, CANL, Vcc, GND) to the bus signal and supply lines. If working in a class, there should be a pre-programmed master node on the bus. If working alone, there should be a bus-on-a-breadboard in storage with Lab1.4 implemented so you have something to behaviorally check your work against.

TODO: ckt diagram

In the example code skeletons, replace `RXD_PIN` and `TXD_PIN` with the appropriate pin name (like `P0_28`). Note that the example solutions use `P0_28` for RXD and `P0_29` for TXD.

## Lab 2.2: Sending CAN Messages
The master node is configured to pulse its white LED on for 0.25 seconds when receiving a CAN message with ID 0x42.

**Objective**: When the button is pressed on your BRAIN, have it transmit a message that triggers a blink on the remote master node.

Start with this code skeleton:

```c++
#include "mbed.h"

#include "ledutils.h"

DigitalOut led1(P0_3);
DigitalOut led2(P0_9);

DigitalIn btn(P0_4);

RawSerial serial(P0_8, NC, 115200);

CAN can(RXD_PIN, TXD_PIN);

int main() {
  // Initialize CAN controller at 1 Mbaud
  can.frequency(1000000);

  while (true) {
    /* YOUR CODE HERE */
  }
}
```

_Remember to replace `RXD_PIN` and `TXD_PIN` with the appropriate pins based on your hardware configuration. Objects declarations for the on-board hardware (LEDs, switches, and a serial console), have been provided for your convenience._

### Detecting Button Presses

The first thing you need to do is to detect a button press. Unlike in the previous lab, where the application was only _level-sensitive_ (cares about the state of the button, whether it is pressed or not), this application is _edge-sensitive_ (we will define a button press as the up to down action). The simplest solution is to, in the main loop, track the previous button state and compare the current button state against the previous state. A button press is when the previous button state is `1` (up) and the current button state is `0` (down). Remember to update the previous button state at the end of each loop.

In keeping with efficient development practices, you may want to test your button press detector in isolation before stacking CAN on top of it. One simple method is to toggle an LED on each press. You may also have it print something to the serial console.

Problems? Common issues may be:
- Remember to declare your previous button state outside the `while (true)` main loop. Otherwise, it will re-initialize each time around the loop and won't be very useful as a persistent tracker.
- Are you losing edges? Make sure the button state compare and update happen atomically with regards to reading the button state. That is, if you read the button during a compare operation, then read it again to update the previous state, there's no guarantee that both reads return the same result, from the same time.
  - A solution around this is to read the button state (once per loop!) into a temporary current state variable, then use that variable in the comparison and update operations.
- Are you detecting multiple edges per press? This is a limitation of mechanical switches: they may bounce for a few milliseconds before they settle. If you sample fast enough, these may register as false edges.
  - One solution is to filter in hardware. The most common approach is adding a RC filter.
  - Debouncing can also be implemented in firmware. One approach is to wait for the switch signal to settle for some amount of time before changing the current state. This requires additional code (and a very small amount of compute), but no hardware (and hence, no recurring costs).
  - For the purposes of this lab, ignore this effect.

### Writing to CAN

Compared to the button press, writing to the CAN bus is simple. First, create a message object using the id-only `CANMessage` constructor:

```c++
CANMessage msg(0x42);
```

Then, transmit that message using `CAN::write(CANMessage)`:

```c++
can.write(msg);
```

Note that you can combine both operations into one line:

```c++
can.write(CANMessage(0x42));
```

Have your edge detection code execute the above on a button press, and you should be done. Feel free to compare against the [solution](solutions/lab2.2.cpp), too.

## Lab 2.3: CAN Messages with Data
When the master node receives a CAN message with ID 0x41, it will pulse its white LED with a length specified by the data field, in milliseconds. The blink length is the first 16-bit integer in the payload, in [big-endian (network order)](https://en.wikipedia.org/wiki/Endianness#Networking) format.

**Objective**: When the button is pressed on your BRAIN, have it transmit a message that triggers a blink on the remote master node at some interesting amount of time (not 250ms as the last lab).

## Lab 2.4: Receiving CAN Messages
Receive a regularly-sent message with a particular ID which sets the RGB LED hue and intensity, allowing all the bus lights to be synchronized.

## Extra for Experts Lab 2.5: Cooperative Multitasking
Pulse a LED on for a second (or so) when a message is received, while doing all of Lab 2.2 and 2.3, using timer-based polling

## Extra for Experts Lab 2.6: Threaded Multitasking
Pulse a LED on for a second (or so) when a message is received, while doing all of Lab 2.2 and 2.3, using mbed RTOS
