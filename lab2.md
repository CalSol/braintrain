# lab2: CAN Bus and Multitasking

## Objectives
Objectives
- Learn the mbed CAN API and the basic underlying principles/
- Learn about and use the different multitasking models on a CAN node.

## Introduction
[CAN (Controller Area Network)](https://en.wikipedia.org/wiki/CAN_bus) is a communications standard used to network electronics in vehicles, including our solar car. While commercial vehicles also have other network standards to choose from (and some may use a combination of several), all the networked devices (including battery management system, motor controller, telemetry, MPPT) on our car communicate over a shared CAN bus.

### Interface Level
A CAN bus consists of at least two devices (nodes) connected to a shared bus, and is a _message-based_, _broadcast_ network:
- Message-based: transmissions occur in complete messages (also called frames).
- Broadcast: all nodes on the network can hear the transmissions of any node (though they need not act on irrelevant messages).

The two main operations are transmitting and receiving messages.

### Message Format
CAN messages carry these pieces of user data:
- ID field, either 11 bits (standard frame) or 29 bits (extended frame). A lower ID gives the message priority in the event of a collision (which happens when multiple nodes start transmitting simultaneously).
- Data, up to 8 bytes. The length is transmitted as part of the frame.
- Remote transmission request (RTR), one bit. This differentiates a remote request frame from a data frame, and more details are below.

The ID field is used to indicate the kind of data being transmitted (for example, "battery voltage") and the data field contains the actual data (continuing the example, 107.4 V encoded as 2 bytes fixed point). Message IDs must be unique on any single CAN bus. Because of the priority system, giving a lower ID to more important messages (or messages with stricter deadlines) is recommended.

Usually, nodes transmit data regularly (for example, battery voltage is automatically sent every second by the BMS), but the RTR field can be used to request specific data. Responding to RTR messages must be handled by application code, and it's not something we use.

CAN also provides these non-user data fields:
- [Cyclic Redundancy Check (CRC)](https://en.wikipedia.org/wiki/Cyclic_redundancy_check), 15 bits, as a checksum so corrupted messages are discarded.
- Acknowledgement, one bit, asserted by any other node upon successful reception (including CRC check).
  - If a message is not acknowledged by any other node, the transmitter will attempt to retransmit.
  - However, it is impossible to tell from the acknowledgement bit if a message was received by a particular node.
  - As acknowledgements are generated by the CAN controller peripheral (before user-level code), it is also impossible to tell if application code has processed and acted on a message correctly.

### Errors
CAN controllers keep count of errors, and too many errors may result in a _bus-off_ condition, where the controller disconnects from the bus. The CAN controller must be re-initialized (through user-level code) before communications can resume. The full list of error counter rules is complex and a more detailed explanation is [here](https://www.kvaser.com/about-can/the-can-protocol/can-error-handling/).

### Physical Layer
_This is only a very high-level overview._

The CAN bus itself consists of two wires, CANH and CANL as a differential pair, to which all nodes are attached. There are two bit levels, either dominant (0) or recessive (1). When multiple nodes transmit simultaneously (collision), a dominant bit takes priority over a recessive bit (the mechanism for ID-based arbitration). If no node is transmitting, the bus is held at a recessive level.

The CAN controller operates on two different, single-ended (non-differential), logic-level lines: TXD and RXD. RXD indicates the current bit level on the CANH/CANL lines, while TXD indicates the bit to transmit.

A CAN transceiver bridges the logic-level TXD/RXD lines and the bus-level CANH/CANL lines. While CAN controllers may be a on-chip peripheral on some microcontrollers, CAN transceivers are usually separate chips and may provide some degree of electrical isolation.

## Lab 2.1: Getting Started: Hardware
The LPC1549 on the BRAINv3.3 has a CAN controller, but no onboard CAN transceiver. You will need to connect the BRAIN to an external CAN transceiver breakout: connect one BRAIN IO to RXD, another to TXD, and the power supply (Vcc and GND) to the 3.3v microcontroller supply. Connect the CAN side lines (CANH, CANL, Vcc, GND) to the bus signal and supply lines. If working in a class, there should be a pre-programmed master node on the bus. If working alone, there should be a bus-on-a-breadboard in storage with Lab1.4 implemented so you have something to behaviorally check your work against.

TODO: ckt diagram

In the example code skeletons, replace `RXD_PIN` and `TXD_PIN` with the appropriate pin name (like `P0_28`). Note that the example solutions use `P0_28` for RXD and `P0_29` for TXD.

## Lab 2.2: Sending CAN Messages
The master node is configured to pulse its LED on for 0.5 seconds when receiving a CAN message with ID 0x42.

**Objective**: When the button is pressed on your BRAIN, have it transmit a message that triggers a blink on the remote master node.

Start with this code skeleton:

```c++
#include "mbed.h"

#include "ledutils.h"

DigitalOut led1(P0_3);
DigitalOut led2(P0_9);

DigitalIn btn(P0_4);

RawSerial serial(P0_8, NC, 115200);

CAN can(RXD_PIN, TXD_PIN);

int main() {
  // Initialize CAN controller at 1 Mbaud
  can.frequency(1000000);

  while (true) {
    /* YOUR CODE HERE */
  }
}
```

_Remember to replace `RXD_PIN` and `TXD_PIN` with the appropriate pins based on your hardware configuration. Objects declarations for the on-board hardware (LEDs, switches, and a serial console), have been provided for your convenience._

### Detecting Button Presses

The first thing you need to do is to detect a button press. Unlike in the previous lab, where the application was only _level-sensitive_ (cares about the state of the button, whether it is pressed or not), this application is _edge-sensitive_ (we will define a button press as the up to down action). The simplest solution is to, in the main loop, track the previous button state and compare the current button state against the previous state. A button press is when the previous button state is `1` (up) and the current button state is `0` (down). Remember to update the previous button state at the end of each loop.

In keeping with efficient development practices, you may want to test your button press detector in isolation before stacking CAN on top of it. One simple method is to toggle an LED on each press. You may also have it print something to the serial console.

Problems? Common issues may be:
- Remember to declare your previous button state outside the `while (true)` main loop. Otherwise, it will re-initialize each time around the loop and won't be very useful as a persistent tracker.
- Are you losing edges? Make sure the button state compare and update happen atomically with regards to reading the button state. That is, if you read the button during a compare operation, then read it again to update the previous state, there's no guarantee that both reads return the same result, from the same time.
  - A solution around this is to read the button state (once per loop!) into a temporary current state variable, then use that variable in the comparison and update operations.
- Are you detecting multiple edges per press? This is a limitation of mechanical switches: they may bounce for a few milliseconds before they settle. If you sample fast enough, these may register as false edges.
  - One solution is to filter in hardware. The most common approach is adding a RC filter.
  - Debouncing can also be implemented in firmware. One approach is to wait for the switch signal to settle for some amount of time before changing the current state. This requires additional code (and a very small amount of compute), but no hardware (and hence, no recurring costs).
  - For the purposes of this lab, ignore this effect.

### Writing to CAN

Compared to the button press, writing to the CAN bus is simple. First, create a message object using the id-only `CANMessage` constructor:

```c++
CANMessage msg(0x42);
```

Then, transmit that message using `CAN::write(CANMessage)`:

```c++
can.write(msg);
```

Note that you can combine both operations into one line:

```c++
can.write(CANMessage(0x42));
```

Have your edge detection code execute the above on a button press, and you should be done. Feel free to compare against the [solution](solutions/lab2.2.cpp), too.

## Lab 2.3: CAN Messages with Data
When the master node receives a CAN message with ID 0x41, it will pulse its LED with a length specified by the data field, in milliseconds. The blink length is the first 16-bit integer in the payload, in [big-endian (network order)](https://en.wikipedia.org/wiki/Endianness#Networking) format.

**Objective**: When the button is pressed on your BRAIN, have it transmit a message that triggers a blink on the remote master node at some interesting amount of time (not 500ms as the last lab).

`CANMessage` has another constructor:

```c++
CANMessage(int _id, const char *_data, char _len = 8, CANType _type = CANData, CANFormat _format = CANStandard)
```

For the purposes of this lab, you only need to consider the first 3 arguments, which specify the ID, payload, and payload length. Your goal will be to pack a 16-bit integer into the byte-oriented payload field. First, start by declaring the blink length (in this example, 1000 ms = 1 second):

```c++
uint16_t blinkLengthMs = 1000;
```

Then, declare a 2-byte vector to store the re-packed payload:

```c++
uint8_t data[2];
```

Pack the data from `blinkLengthMs` into `data`, one byte at a time. Usually, this is accomplished by shifting the 8 bits to be packed into the leasy significant byte, then masking out the other bytes. For example, to get bits 15...8, we would write:

```c++
data[0] = (blinkLengthMs >> 8) & 0xff;
```

This right shifts blinkLengthMs by 8, so that bits 15...8 are now in bits 7...0. The masking isn't really necessary for a 16-bit integer, but would be if you were taking a byte in the middle of a larger (32-bit, for example) integer.

After you've packed `data[1]`, you can construct the CAN message and send it. A convenient one-liner is:

```c++
can.write(CANMessage(0x41, (char*)data, 2));
```

This creates a CAN message with id=0x41 and payload with 2 bytes from `data`. Note that the CANMessage API inexplicably takes in a `char*` (rather than an `unsigned char*` or `uint8_t*` type, so the `(char*)` cast is required.

Run it, press the button, and check that the master pulses its LED for the duration you programmed. A [reference solution](solutions/lab2.3.cpp) is also available for the curious.

## Lab 2.4: Receiving CAN Messages
You may notice that the master node is constantly cycling the hue of its RGB LED. It also broadcasts the RGB LED's hue regularly, allowing other nodes to synchronize with it.

**Objective**: Have your BRAIN's RGB LED track and mimic the master's RGB LED.

_Note: you may think another way to accomplish this objective is to run both nodes open-loop, but starting both at the same time. The reason this does not work well is because of clock drift: since each node has its own (non-synchronized) clock source, the timing will be slightly off and their hues will drift. While the crystals on the BRAINs provide good frequency tolerance and stability, they will still de-synchronize over long periods of time._

### RGB LED Helper
Start by declaring a RGB LED object. For convenience, a `RGBPwmLed` object has been provided in the `ledutils.h` header. Instantiate one as follows:

```c++
RGBPwmOut rgbLed(P0_5, P0_6, P0_7);
```

It has one API function, which sets the R, G, B PWM outputs using an input H, S, V. The hue is specified in centi-degrees [0, 36000), while the saturation and value are specified in 16-bit fixed point [0, 65535].

```c++
RGBPwmOut::hsv_uint16(uint16_t h_cdeg, uint16_t s, uint16_t v);
```

### Reading from CAN
Messages can be read from a CAN object using `CAN::read(CANMessage&)`. If there was a message pending, the function returns 1 and stores the message in the input (reference) argument. If there was no message pending, the function return 0.

> In lab1, you learned about pointers. C++ also has _reference_ types, denoted with `&`, which act like pointers but use value notation. You can see its use in `CAN::read`, allowing the function to return both a read status (as its return value) and a message.
>
> Note: some style guides discourage the use of references as output values, preferring to use pointer notation to make it explicit that an argument may be overwritten.

A common structure for checking for messages is:

```c++
CANMessage msg;
while (can.read(msg)) {
  // do something based on the received message
}
```

> `CANMessage` (of type `CAN_Message`) has the structure:
>
> ```c++
> struct CAN_Message {
>     unsigned int   id;                 // 29 bit identifier
>     unsigned char  data[8];            // Data field
>     unsigned char  len;                // Length of data field in bytes
>     CANFormat      format;             // 0 - STANDARD, 1- EXTENDED IDENTIFIER
>     CANType        type;               // 0 - DATA FRAME, 1 - REMOTE FRAME
> };
> ```
>
> For this lab, we'll only consider `id`, and `data`.

The master node broadcasts its hue, in centi-degrees, as a 16-bit integer in the payload of a CAN message with id=0x43. You will have to unpack the byte-oriented data from the CAN message into a 16-bit hue (essentially using the opposite process in lab 2.3) and write it to the hue of the RGB LED. Use saturation = 65535 and value (brightness) = 32767. Don't forget that the hue should only be changed upon receiving a message with id=0x43 - there may be other network traffic on the CAN network.

Once you're done, you can compare against the [reference solution](solutions/lab2.4.cpp).

## Extra for Experts Lab 2.5: Cooperative Multitasking
A microcontroller that can only do one thing is quite limiting, so let's put together the push-to-blink functionality (lab 2.2), the RGB LED hue update functionality (lab 2.4), and also the master LED pulse functionality. Note that the master code is set up such with the functionality in lab 2.2, where a button press causes it to send a CAN message with id=0x42.

**Objective**: Upon receiving a CAN message with id=0x42, have your BRAIN pulse an LED on for 0.5s. While also updating the RGB LED hue from remote messages and sending a CAN message on a button press.

### The Deceptively Simple Way
The simplest way would be to add another message handler in the `can.read(msg)` loop:

```c++
CANMessage msg;
while (can.read(msg)) {
  if (msg.id == 0x43) {
    // hue code here
  } else if (msg.id == 0x42) {
    led2 = 1;
    wait(0.5);
    led2 = 0;
  }
}
```

Try it, and it works, but only kind of. The problem is that the `wait` is blocking - it doesn't return, so the system can't do other things (like update the RGB LED hue from received CAN messages or detect button presses). This is noticeable: during the LED pulse time, the RGB LED hue will freeze, then jump to the newest received value. Obviously, this looks bad, and this _is_ bad.

### The Robust Way
Most microcontrollers have built-in timer peripherals (essentially counters that tick in the background, independently of what the CPU is doing) and can be queried for the current count. mbed provides the `Timer` class as a hardware abstraction layer. A `Timer` has these operations:
- `Timer::start()`: starts the timer. Timers start off (not ticking).
- `Timer::reset()`: resets the passed time to 0. Does not change start / stopped state.
- `Timer::stop()`: self-explanatory.
- `Timer::read()`: reads the passed time, in seconds, as a float.
- `Timer::read_ms()`, `Timer::read_us()`: reads the passed time as an integer.

Given that, we could restructure our code so that upon receiving the LED pulse message, the LED is turned on and a timer is started and reset. Then, regularly in the main loop, the timer is read and compared against the threshold time (500 ms here). Once it goes over the threshold, the LED is turned off. Since no blocking operations are performed, the RGB LED hue will continue updating while the LED is on.

This style is called _cooperative multitasking_ because the different tasks must co-operate and yield control to other tasks regularly. For example, when we have a blocking wait in the deceptively simple method, the LED pulsing prevented the RGB LED hue from updating. This type of multitasking is simple, explicit (almost nothing going on "behind the scenes"), but also vulnerable to poor code like blocking operations.

Implement the non-blocking pulsing LED, and verify that it works (RGB LED hue continues updating throughout the LED pulse such that you don't see visible hue discontinuities). Once you're done, you can check against the [reference solution](solutions/lab2.5.cpp).

## Extra for Experts Lab 2.6: Threaded Multitasking
_While we currently don't use threading in our codebase, it's still a common programming model and is worthwhile to learn its features and pitfalls._

While cooperative multitasking accomplished our goals, it did so by spreading code around - for example, while we would interpret the LED blink as a logical unit, it actually ended up separated into two phases. In this section, we will explore a different approach to multitasking: threading and operating systems.

**Objective**: Lab 2.5, but using the mbed RTOS.

> A _thread_ is a sequence of instructions in a program. In the examples above, the entire program consisted of one thread, `main()`. However, with a _scheduler_ (a typical component in an _operating system_), it is possible to run multiple threads at once - typically, the scheduler interleaves the threads in time onto one processor. Across threads within a process, resources like memory are shared.
>
> There are many different models of communications between threads. The simplest, but most dangerous, is by manipulating shared memory. More structured communications channels are also available, like locks, semaphores, and queues. In this section, we will focus on queues as they are a robust while conceptually simple channel.
>
> A _real-time operating system_ is an operating system that attempts to meet real-time constraints, generally prioritizing latency over throughput. There are two types: _hard real-time_ systems are guaranteed to meet task deadlines, while _soft real-time_ systems provide no such guarantees. The mbed RTOS consists of a task scheduler but provides no task deadline guarantees (or even any static timing analysis capability), and is a soft real-time system.
>
> Multitasking in general is a hard problem, and this tutorial only covers the very basics.

While the RTOS library has been included in the standard build, we haven't used it ... until now. Let's start by structuring our threads:
- the `main` thread will handle CAN communications, dispatching notifications to other threads based on received data
- a LED thread will blink the LED upon receiving a notification
- a button thread will notify the CAN thread to transmit a message

Start by including the RTOS header:
```c++
#include "rtos.h"
```

Then, declare two [`Thread`](https://developer.mbed.org/handbook/RTOS#thread) objects (note: `main` is implicitly its own thread):

```c++
Thread ledThread;
Thread buttonThread;
```

Each Thread will run a function, the skeletons of which are provided:

```c++
void led_thread() {
  while (true) {
    // TODO: pulse LED upon receiving notification
  }
}

void button_thread() {
  bool lastButton = true;
  while (true) {
    bool thisButton = btn;
    if (thisButton != lastButton && btn == 0) {
      // TODO: enqueue a CAN message with id=0x42 for transmission upon button press
    }
    lastButton = thisButton;

    Thread::wait(5);
  }
}
```

One important note is the use of `Thread::wait(uint32_t millisec)`, as opposed to bare `wait`. `Thread::wait` de-schedules the thread (allowing other threads to run as it is waiting), as opposed to spinning (which takes up compute resources doing nothing). As the button is sampled sufficiently slowly, there is no need to debounce.

With the `Thread` objects and functions, we are now ready to write our `main` function:

```c++
int main() {
  // Initialize CAN controller at 1 Mbaud
  can.frequency(1000000);

  ledThread.start(led_thread);
  buttonThread.start(button_thread);

  while (true) {
    // CAN receive handling
    CANMessage msg;
    while (can.read(msg)) {
      if (msg.id == 0x43) {
        uint16_t hue = (msg.data[0] << 8) | (msg.data[1] << 0);
        rgbLed.hsv_uint16(hue, 65535, 32767);
      } else if (msg.id == 0x42) {
        // TODO: notify the LED thread to pulse the LED
      }
    }

    // CAN transmit handling
    // TODO: transmit CAN messages

    Thread::yield();
  }
}
```

You'll notice two new constructs here:
- `Thread::start(*fn)` starts a `Thread` object at a given function. From then on, the argument function and the calling thread will run in parallel.
- `Thread::yield()` "yields" the current thread, allowing other threads a chance to run. While the operating system will pre-empt (and switch to another thread) if one thread has been running for too long, proactively yielding when a thread has no more work (for example, waiting on input when polling) is good practice.

Next, define the two communication channels. One will be a queue of pulse times for the LED, and another will be a queue of CAN messages to transmit:

```c++
Mail<CANMessage, 16> canTransmitQueue;
Mail<uint16_t, 1> ledQueue;
```

[`Mail`](https://developer.mbed.org/handbook/RTOS#mail) is a queue that stores elements (not to be confused with [`Queue`](https://developer.mbed.org/handbook/RTOS#queue), which can only store pointers. The first type parameter is the data type that is stored, and the second parameter is the number of elements in the queue. In the example above, `canTransmitQueue` consists of up to 16 elements of type `CANMessage`.

`Mail`'s API is kind of funny:
- To enqueue an element, you first need to allocate storage space using `Mail::alloc()`, which returns a pointer to an element that you need to initialize. Then, you can actually enqueue the element using `Mail::put(elem)` For example, to enqueue a wait time of 500ms into `ledQueue`:

  ```c++
  uint16_t* waitTime = ledQueue.alloc(osWaitForever);
  *waitTime = 500;
  ledQueue.put(waitTime);
  ```

  Note: `Mail::alloc()` takes an optional parameter of the maximum time to wait for a free element buffer. In the above, we essentially do a blocking allocation, waiting indefinitely until one is available. If a finite time is passed in, `alloc` can fail and return `NULL`.
- To dequeue an element, use `osEvent evt = Mail::get()`, which returns an object of type `osEvent`. The object's `status` field indicates the event's meaning, and we are interested in the case when `evt.status == osEventMail`. For a mail event, we can get a pointer to the element using `evt.value.p` followed by a typecast. Remember to `Mail::free()` the pointer when done so the element memory can be re-used. An example for polling and reading `ledQueue` is:

  ```c++
  osEvent evt = ledQueue.get();
  if (evt.status == osEventMail) {
    uint16_t waitTime = *(uint16_t*)evt.value.p;
    ledQueue.free((uint16_t*)evt.value.p);
    led2 = 1;
    Thread::wait(waitTime);
    led2 = 0;
  }
  ```

  You can see that all the LED code is cleanly centralized into one location. Also note that `Mail::get()` takes an optional maximum wait time too, defaulting to forever (essentially blocking until a message is available).

Putting the two above examples together, our full code now looks like:

```c++
#include "mbed.h"
#include "rtos.h"

#include "ledutils.h"

RGBPwmOut rgbLed(P0_5, P0_6, P0_7);

DigitalOut led1(P0_3);
DigitalOut led2(P0_9);

DigitalIn btn(P0_4);

RawSerial serial(P0_8, NC, 115200);

CAN can(P0_28, P0_29);

Mail<CANMessage, 16> canTransmitQueue;

Thread ledThread;
Mail<uint16_t, 1> ledQueue;
void led_thread() {
  while (true) {
    osEvent evt = ledQueue.get();
    if (evt.status == osEventMail) {
      uint16_t waitTime = *(uint16_t*)evt.value.p;
      ledQueue.free((uint16_t*)evt.value.p);
      led2 = 1;
      Thread::wait(waitTime);
      led2 = 0;
    }
  }
}

Thread buttonThread;
void button_thread() {
  bool lastButton = true;
  while (true) {
    bool thisButton = btn;
    if (thisButton != lastButton && btn == 0) {
      // TODO: enqueue a CAN message with id=0x42 for transmission upon button press
    }
    lastButton = thisButton;

    Thread::wait(5);
  }
}

int main() {
  // Initialize CAN controller at 1 Mbaud
  can.frequency(1000000);

  ledThread.start(led_thread);
  buttonThread.start(button_thread);

  while (true) {
    // CAN receive handling
    CANMessage msg;
    while (can.read(msg)) {
      if (msg.id == 0x43) {
        uint16_t hue = (msg.data[0] << 8) | (msg.data[1] << 0);
        rgbLed.hsv_uint16(hue, 65535, 32767);
      } else if (msg.id == 0x42) {
        uint16_t* waitTime = ledQueue.alloc(osWaitForever);
        *waitTime = 500;
        ledQueue.put(waitTime);
      }
    }

    // CAN transmit handling
    // TODO: transmit CAN messages

    Thread::yield();
  }
}
```

Test that it works, that you can simultaneously blink the LED while still updating the RGB LED. Afterwards, fill out the two TODOs in the same style as the LED enqueue / dequeue operations.

Once you've given it a shot, check out the [reference solution](solutions/lab2.6.cpp).

### Discussion
_With great power comes great responsibility._

Now that we've implemented the same functionality in both cooperative multitasking and threaded forms, let's compare.

What did we gain with threading?
- Related sequences of instructions appear as a single unit in code, even if their execution is separated by other threads. This is apparent in the LED pulsing code.
- The appearance of multitasking without needing to handle the details manually, as with cooperative multitasking.
- Communication between tasks are made explicit with the use of `Mail` queues.

What pitfalls did we avoid?
- The use of `Mail` queues provides a principled way to communicate between threads. Threading actually exposes a shared memory model, where threads can read and write each other's memory, and not being careful and methodical can lead to subtle, non-deterministic bugs like [race conditions](https://en.wikipedia.org/wiki/Race_condition).
- The mbed RTOS has implementation limitations, like maximum number of threads and predefined maximum stack size. While this trivial example stayed within the limits, the RTOS isn't always able to produce a helpful error message on failure, making debugging painful.

What did we lose with threading?
- The actual execution behavior of the RTOS isn't predictable, especially with regards to very fine (milliseconds) timing. While the thread scheduler gives the illusion of multiple threads executing simultaneously, the actual thread swapping occurs at human timescales (every few milliseconds) rather than machine timescales.

Overall, threading provides a different approach than cooperative multitasking and can be a powerful tool in certain situations, but only if you're aware of the pitfalls and shortcomings. If you're interested in using threading for your project, do talk to us so we can discuss whether it's appropriate and how to mitigate the potential issues.
