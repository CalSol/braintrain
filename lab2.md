# lab2: CAN Bus and Multitasking

## Objectives
Objectives
- Learn the mbed CAN API and the basic underlying principles/
- Learn about and use the different multitasking models on a CAN node.

## Introduction
[CAN (Controller Area Network)](https://en.wikipedia.org/wiki/CAN_bus) is a communications standard used to network electronics in vehicles, including our solar car. While commercial vehicles also have other network standards to choose from (and some may use a combination of several), all the networked devices (including battery management system, motor controller, telemetry, MPPT) on our car communicate over a shared CAN bus.

### Interface Level
A CAN bus consists of at least two devices (nodes) connected to a shared bus, and is a _message-based_, _broadcast_ network:
- Message-based: transmissions occur in complete messages (also called frames).
- Broadcast: all nodes on the network can hear the transmissions of any node (though they need not act on irrelevant messages).

The two main operations are transmitting and receiving messages.

### Message Format
CAN messages carry these pieces of user data:
- ID field, either 11 bits (standard frame) or 29 bits (extended frame). A lower ID gives the message priority in the event of a collision (which happens when multiple nodes start transmitting simultaneously).
- Data, up to 8 bytes. The length is transmitted as part of the frame.
- Remote transmission request (RTR), one bit. This differentiates a remote request frame from a data frame, and more details are below.

The ID field is used to indicate the kind of data being transmitted (for example, "battery voltage") and the data field contains the actual data (continuing the example, 107.4 V encoded as 2 bytes fixed point). Message IDs must be unique on any single CAN bus. Because of the priority system, giving a lower ID to more important messages (or messages with stricter deadlines) is recommended.

Usually, nodes transmit data regularly (for example, battery voltage is automatically sent every second by the BMS), but the RTR field can be used to request specific data. Responding to RTR messages must be handled by application code, and it's not something we use.

CAN also provides these non-user data fields:
- [Cyclic Redundancy Check (CRC)](https://en.wikipedia.org/wiki/Cyclic_redundancy_check), 15 bits, as a checksum so corrupted messages are discarded.
- Acknowledgement, one bit, asserted by any other node upon successful reception (including CRC check).
  - If a message is not acknowledged by any other node, the transmitter will attempt to retransmit.
  - However, it is impossible to tell from the acknowledgement bit if a message was received by a particular node.
  - As acknowledgements are generated by the CAN controller peripheral (before user-level code), it is also impossible to tell if application code has processed and acted on a message correctly.

### Errors
CAN controllers keep count of errors, and too many errors may result in a _bus-off_ condition, where the controller disconnects from the bus. The CAN controller must be re-initialized (through user-level code) before communications can resume. The full list of error counter rules is complex and a more detailed explanation is [here](https://www.kvaser.com/about-can/the-can-protocol/can-error-handling/).

### Physical Layer
_This is only a very high-level overview._

The CAN bus itself consists of two wires, CANH and CANL as a differential pair, to which all nodes are attached. There are two bit levels, either dominant (0) or recessive (1). When multiple nodes transmit simultaneously (collision), a dominant bit takes priority over a recessive bit (the mechanism for ID-based arbitration). If no node is transmitting, the bus is held at a recessive level.

The CAN controller operates on two different, single-ended (non-differential), logic-level lines: TXD and RXD. RXD indicates the current bit level on the CANH/CANL lines, while TXD indicates the bit to transmit.

A CAN transceiver bridges the logic-level TXD/RXD lines and the bus-level CANH/CANL lines. While CAN controllers may be a on-chip peripheral on some microcontrollers, CAN transceivers are usually separate chips and may provide some degree of electrical isolation.

## Lab 2.1: Getting Started: Hardware
The LPC1549 on the BRAINv3.3 has a CAN controller, but no onboard CAN transceiver. You will need to connect the BRAIN to an external CAN transceiver breakout: connect one BRAIN IO to RXD, another to TXD, and the power supply (Vcc and GND) to the 3.3v microcontroller supply. Connect the CAN side lines (CANH, CANL, Vcc, GND) to the bus signal and supply lines. If working in a class, there should be a pre-programmed master node on the bus. If working alone, there should be a bus-on-a-breadboard in storage with Lab1.4 implemented so you have something to behaviorally check your work against.

TODO: ckt diagram

In the example code skeletons, replace `RXD_PIN` and `TXD_PIN` with the appropriate pin name (like `P0_28`). Note that the example solutions use `P0_28` for RXD and `P0_29` for TXD.

## Lab 2.2: Sending CAN Messages
The master node is configured to pulse its white LED on for 0.25 seconds when receiving a CAN message with ID 0x42.

**Objective**: When the button is pressed on your BRAIN, have it transmit a message that triggers a blink on the remote master node.

Start with this code skeleton:

```c++
#include "mbed.h"

#include "ledutils.h"

DigitalOut led1(P0_3);
DigitalOut led2(P0_9);

DigitalIn btn(P0_4);

RawSerial serial(P0_8, NC, 115200);

CAN can(RXD_PIN, TXD_PIN);

int main() {
  // Initialize CAN controller at 1 Mbaud
  can.frequency(1000000);

  while (true) {
    /* YOUR CODE HERE */
  }
}
```

_Remember to replace `RXD_PIN` and `TXD_PIN` with the appropriate pins based on your hardware configuration. Objects declarations for the on-board hardware (LEDs, switches, and a serial console), have been provided for your convenience._

### Detecting Button Presses

The first thing you need to do is to detect a button press. Unlike in the previous lab, where the application was only _level-sensitive_ (cares about the state of the button, whether it is pressed or not), this application is _edge-sensitive_ (we will define a button press as the up to down action). The simplest solution is to, in the main loop, track the previous button state and compare the current button state against the previous state. A button press is when the previous button state is `1` (up) and the current button state is `0` (down). Remember to update the previous button state at the end of each loop.

In keeping with efficient development practices, you may want to test your button press detector in isolation before stacking CAN on top of it. One simple method is to toggle an LED on each press. You may also have it print something to the serial console.

Problems? Common issues may be:
- Remember to declare your previous button state outside the `while (true)` main loop. Otherwise, it will re-initialize each time around the loop and won't be very useful as a persistent tracker.
- Are you losing edges? Make sure the button state compare and update happen atomically with regards to reading the button state. That is, if you read the button during a compare operation, then read it again to update the previous state, there's no guarantee that both reads return the same result, from the same time.
  - A solution around this is to read the button state (once per loop!) into a temporary current state variable, then use that variable in the comparison and update operations.
- Are you detecting multiple edges per press? This is a limitation of mechanical switches: they may bounce for a few milliseconds before they settle. If you sample fast enough, these may register as false edges.
  - One solution is to filter in hardware. The most common approach is adding a RC filter.
  - Debouncing can also be implemented in firmware. One approach is to wait for the switch signal to settle for some amount of time before changing the current state. This requires additional code (and a very small amount of compute), but no hardware (and hence, no recurring costs).
  - For the purposes of this lab, ignore this effect.

### Writing to CAN

Compared to the button press, writing to the CAN bus is simple. First, create a message object using the id-only `CANMessage` constructor:

```c++
CANMessage msg(0x42);
```

Then, transmit that message using `CAN::write(CANMessage)`:

```c++
can.write(msg);
```

Note that you can combine both operations into one line:

```c++
can.write(CANMessage(0x42));
```

Have your edge detection code execute the above on a button press, and you should be done. Feel free to compare against the [solution](solutions/lab2.2.cpp), too.

## Lab 2.3: CAN Messages with Data
When the master node receives a CAN message with ID 0x41, it will pulse its white LED with a length specified by the data field, in milliseconds. The blink length is the first 16-bit integer in the payload, in [big-endian (network order)](https://en.wikipedia.org/wiki/Endianness#Networking) format.

**Objective**: When the button is pressed on your BRAIN, have it transmit a message that triggers a blink on the remote master node at some interesting amount of time (not 250ms as the last lab).

`CANMessage` has another constructor:

```c++
CANMessage(int _id, const char *_data, char _len = 8, CANType _type = CANData, CANFormat _format = CANStandard)
```

For the purposes of this lab, you only need to consider the first 3 arguments, which specify the ID, payload, and payload length. Your goal will be to pack a 16-bit integer into the byte-oriented payload field. First, start by declaring the blink length (in this example, 1000 ms = 1 second):

```c++
uint16_t blinkLengthMs = 1000;
```

Then, declare a 2-byte vector to store the re-packed payload:

```c++
uint8_t data[2];
```

Pack the data from `blinkLengthMs` into `data`, one byte at a time. Usually, this is accomplished by shifting the 8 bits to be packed into the leasy significant byte, then masking out the other bytes. For example, to get bits 15...8, we would write:

```c++
data[0] = (blinkLengthMs >> 8) & 0xff;
```

This right shifts blinkLengthMs by 8, so that bits 15...8 are now in bits 7...0. The masking isn't really necessary for a 16-bit integer, but would be if you were taking a byte in the middle of a larger (32-bit, for example) integer.

After you've packed `data[1]`, you can construct the CAN message and send it. A convenient one-liner is:

```c++
can.write(CANMessage(0x41, (char*)data, 2));
```

This creates a CAN message with id=0x41 and payload with 2 bytes from `data`. Note that the CANMessage API inexplicably takes in a `char*` (rather than an `unsigned char*` or `uint8_t*` type, so the `(char*)` cast is required.

Run it, press the button, and check that the master pulses its LED for the duration you programmed. A [reference solution](solutions/lab2.3.cpp) is also available for the curious.

## Lab 2.4: Receiving CAN Messages
You may notice that the master node is constantly cycling the hue of its RGB LED. It also broadcasts the RGB LED's hue regularly, allowing other nodes to synchronize with it.

**Objective**: Have your BRAIN's RGB LED track and mimic the master's RGB LED.

_Note: you may think another way to accomplish this objective is to run both nodes open-loop, but starting both at the same time. The reason this does not work well is because of clock drift: since each node has its own (non-synchronized) clock source, the timing will be slightly off and their hues will drift. While the crystals on the BRAINs provide good frequency tolerance and stability, they will still de-synchronize over long periods of time._

### RGB LED Helper
Start by declaring a RGB LED object. For convenience, a `RGBPwmLed` object has been provided in the `ledutils.h` header. Instantiate one as follows:

```c++
RGBPwmOut rgbLed(P0_5, P0_6, P0_7);
```

It has one API function, which sets the R, G, B PWM outputs using a input H, S, V. The hue is specified in centi-degrees [0, 36000), while the saturation and value are specified in 16-bit fixed point [0, 65535].

```c++
RGBPwmOut::hsv_uint16(uint16_t h_cdeg, uint16_t s, uint16_t v);
```

### Reading from CAN
Messages can be read from a CAN object using `CAN::read(CANMessage&)`. If there was a message pending, the function returns 1 and stores the message in the input (reference) argument. If there was no message pending, the function return 0.

> In lab1, you learned about pointers. C++ also has _reference_ types, denoted with `&`, which act like pointers but use value notation. You can see its use in `CAN::read`, allowing the function to return both a read status (as its return value) and a message.
>
> Note: some style guides discourage the use of references as output values, preferring to use pointer notation to make it explicit that an argument may be overwritten.

A common structure for checking for messages is:

```c++
CANMessage msg;
while (can.read(msg)) {
  // do something based on the received message
}
```

> `CANMessage` (of type `CAN_Message`) has the structure:
>
> ```c++
> struct CAN_Message {
>     unsigned int   id;                 // 29 bit identifier
>     unsigned char  data[8];            // Data field
>     unsigned char  len;                // Length of data field in bytes
>     CANFormat      format;             // 0 - STANDARD, 1- EXTENDED IDENTIFIER
>     CANType        type;               // 0 - DATA FRAME, 1 - REMOTE FRAME
> };
> ```
>
> For this lab, we'll only consider `id`, and `data`.

The master node broadcasts its hue, in centi-degrees, as a 16-bit integer in the payload of a CAN message with id=0x43. You will have to unpack the byte-oriented data from the CAN message into a 16-bit hue (essentially using the opposite process in lab 2.3) and write it to the hue of the RGB LED. Use saturation = 65535 and value (brightness) = 32767. Don't forget that the hue should only be changed upon receiving a message with id=0x43 - there may be other network traffic on the CAN network.

Once you're done, you can compare against the [reference solution](solutions/lab2.4.cpp).

## Extra for Experts Lab 2.5: Cooperative Multitasking
Pulse a LED on for a second (or so) when a message is received, while doing all of Lab 2.2 and 2.3, using timer-based polling

## Extra for Experts Lab 2.6: Threaded Multitasking
Pulse a LED on for a second (or so) when a message is received, while doing all of Lab 2.2 and 2.3, using mbed RTOS
